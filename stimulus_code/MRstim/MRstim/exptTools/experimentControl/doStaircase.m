function [dataSum] = doStaircase(display, stairParams, stimParams, trialGenFuncName, priority, logFID, varargin)% [dataSum] = doStaircase(display, stairParams, stimParams, trialGenFuncName, [priority], [logFID],%															['optionFlag1'], ['optionFlag2'], ...)%	display:			(struct)	display parameters%%	stairParams:		(struct)	staircase parameters (see below)%%	stimParams:			(struct)	stimulus parameters%%	trialGenFuncName	(string)	specifies the function called to generate the stimuli.%									This function must exist in the current matlab path and%									must assume the following form (replacing trialGenFuncName%									with the correct function name):%										[trial, data] = trialGenFuncName(display, stimParams, data)%									Use 'data' for whatever you would like to be preserved from%									trial to trial (pre-computed images, colormaps, etc.).%%	priority			(int)		optional- specifies run priority (0-7, 0 is default)%%	logFID				(int)		optional- specifies where log data go- default is the screen.%									if logFID is a vector, each of the files specified will be%									written to.  All files written as text files.%%	optionFlags			(string)	Specify any number of the following options:%										precomputeFirstTrial:	this option is really only useful%																if your trialGenFunction saves%																stuff in the 'data' structure that%																will save time when building%																subsequent trials.%										precomputeAllTrials:	this option builds all the trials%																ahead of time.  It may take a while%																to do this, especially if you have%																alot of adjustableVarValues!  Also%																note that randomization will be%																systematic- trials in a staircase%																with the same adjustableVarValue%																will have the same randVarValues%																and the same alternativeVarValue.%																You can make things seem more random%																by doing several staircases.  Or, you%																may want to do the precomputing in%																your trialGenFunction and leave this%																option off.%%%%stairParams structure:%%	stairParams.alternativeVarName = 'testPosition';%	stairParams.alternativeVarValues = ['L' 'R'];%		This must be a fieldname of stimParams.  The values are selected from the%		list at random and a trial is counted as 'correct' if the alternative%		index and the response index are the same.  (e.g., if the second%		alternative was presented and the second response of the response set%		was entered, then the trial will be counted as correct.)%%   stairParams.adjustableVarName = 'varName';%		This must be a fieldname of stimParams.  The values are selected%		systematicallly from stairParams.stimLevels according to the rules%		defined by the parameters below.%%   stairParams.adjustableVarStart = [1 1];%		The length of this vector determines the number of interleaved staircases%		(referred to as numStairs in this file).% 		Each value in this vector is an index into stairParams.adjustableVarStart%		which determines where each of the staircases start.%%	stairParams.adjustableVarValues = [10.^[0:-.1:-2]];%		An 1 x N vector or numStairs x N matrix specifying the N different stimulus%		levels (N can be any value).  If the number of rows is < numStairs, then the%		adjustableVarValues for all subsequent staircases are taken from the levels%		of the last staircase specified (e.g., if it is 1 x N, then all staircases%		will use the same levels).%%	stairParams.randomVars = {'varName' [0:3:9]};%		This is a cell array that may contain any number of rows, where each row is%		a stimParams field name (the variable you want randomized) and a vector listing%		the possible values.  DoStaircase will randomly assign a value from the list%		to the variable(s) before each trial.%%	stairParams.curStairVars = {'varName', [1 2 3]};%		This is a cell array that may contain any number of rows, where each row is%		a stimParams field name (the variable you want varied) and a vector listing%		the possible values.  DoStaircase will assign a value from the list%		to the variable(s) before each trial, based on the current staircase.%		That is, the first value will be used when doing a trial for the first%		interleaved staircase, the second value used for the second staircase, etc.%%	stairParams.numCorrectForStep = 2;%	stairParams.numIncorrectForStep = 1;%		These two determine how many consecutive correct and how many consecutive%		incorrect responses are needed before adjusting the adjustableVarValue.%%	stairParams.correctStepSize = 2;%	stairParams.incorrectStepSize = 1;%		These two determine how many index units (of stairParams.stimLevels) to%		jump with a correct (or incorrect) response sequence that meets the%		criteria defined by stairParams.numCorrectForStep/.numIncorrectForStep.%%	stairParams.maxNumTrials = 100;%	stairParams.maxNumReversals = 10;%		The staircase ends when either of these conditions are met.%%	stairParams.feedback = 'click';%		feedback options: 'none', 'click', 'auditory'.  ('click' clicks when a%		valid response is registered, but does not indicate correct/incorrect.)%		You can also provide feedback through the trial structure, including more%		elaborate visual feedback.%%	stairParams.responseSet = '13';%		This is a string listing acceptable responses (no spaces!)%		Alternative 1 is the first character in this sting, alternative 2 the second,%		and so on.  Do not use q or Q- these characters are special and cause the experient%		to abort.  If this field is omitted, then doStaircase will expect the trial%		to return a response.%%	stairParams.conditionName = {'cond1'; 'cond2'};%		This is a cell array where each row is the condition name for a staircase.%		For example, the first row should contain the condition name for the first%		staircase, the second row the name for the second staircase, and so on.%		If there are fewer rows than staircases, the the staircases without%		specified naems get the name of the last named staircase.  If this field%		is omitted, all staircases get the name of the adjustableVar.%%   stairparams.iti = 0.1;%       Inter-trial interval, in seconds. (defaults to 0)%%%% 98/10/08 coded by Bob Dougherty (aka RFD)% 98/10/14 got into a working form by Bob Dougherty (lots of advice from WAP and BTB)% 98/10/20 RFD: added varargin option flags to precompute trials.  Modified 'data' to be%				a cell array so that each interleaved staircases can have their own%				data.  Also, added reversalStimLevel to dataSum.% 98/10/26 RFD: added history field to dataSum (keeps a history of the adjustableVarValue%				presented on each trial).  Also added "save('dataSumTemp', 'dataSum');"%				so that the summary data are not lost in the event of an error or crash.% 98/10/26 RFD: added stairParams.conditionName.% 98/11/02 RFD: fixed precomputeFurstTrial so that it sets the first adjustableVarValue%				before building the trial.% 98/11/04 RFD: Added code to clear the keyboard queue before each trial so that any%				inadvertant keypresses will not count as responses.% 98/11/06 RFD: Fixed the reversal-checking code so that it works properly now!% 98/11/13 RFD: Fixed the reversal-checking code so that it does the right thing%				without bombing when there are more than one interleaved staircases.% 98/11/24 RFD: Fixed the code which checks to see if all the staircases have finished.%				(The error was only evident with multiple staircases- it was ending%				when at least one of the staircases had reached it's stop criteia- now it%				ends only when _all_ the staircases have reached their stop criteria.)% 98/12/04 RFD  Modified the adjustable var algorithm so that it counts as a reversal%               a trial that must be constrained to the adjustable var boundaries.%               (e.g., if the observer hits the minimum adjustable var value and the%               algorithm tries to go even lower, it will count as a reversal.)%               This avoids excessively long runs where the observer has hit the%               upper or lower boundary (because without this fix, no true reversals%               will be tallied).% 2008/05/14 JW Added a check to check whether user wants to display timing%               for each trial (default is to show timing). Flag can be set%               in stairParams.showTiming.if nargin < 4    error('not enough input arguments- type help doStaircase');endif ~exist('priority', 'var')    priority = 0;endif ~exist('logFID', 'var')    logFID = 1;endif isfield(stairParams, 'showTiming')    showTimingFlag = stairParams.showTiming;else    showTimingFlag = true;end% Seed random number generatorClockRandSeed;%if ~isfield(stimParams, stairParams.adjustableVarName)%	error('stairParams.adjustableVarName is not a field of stimParams!');%end% set some defaultsif ~isfield(stairParams, 'numIncorrectBeforeStep')    stairParams.numIncorrectBeforeStep = 1;endif ~isfield(stairParams, 'randomVars')    stairParams.randomVars = {};endif ~isfield(stairParams, 'feedback')    stairParams.feedback = 'auditory';endif ~isfield(stairParams, 'curStairVars')    stairParams.curStairVars = {};endif ~isfield(stairParams, 'conditionName')    if size(stairParams.curStairVars,1)<1        stairParams.conditionName = stairParams.adjustableVarName;    else        for ii=1:length(stairParams.adjustableVarStart)            for jj=1:size(stairParams.curStairVars,1)                stairParams.conditionName{ii,jj*2-1} = stairParams.curStairVars{jj,1};                stairParams.conditionName{ii,jj*2} = ...                    stairParams.curStairVars{jj,2}(min(length(stairParams.curStairVars{jj,2}),ii));            end        end    endendif ~isfield(stairParams, 'iti')    stairparams.iti = 0.0;endnumStairs = length(stairParams.adjustableVarStart);numLevels = size(stairParams.adjustableVarValues, 2);% generate auditory feedbackif isfield(stairParams, 'feedback')    if strcmp(stairParams.feedback,'auditory')        correctSnd = soundFreqSweep(200, 500, .1);        incorrectSnd = soundFreqSweep(500, 200, .1);    elseif  strcmp(stairParams.feedback,'click')        % make them both the same- a click to acknowledge the response        correctSnd = soundFreqSweep(500, 1000, .01);        incorrectSnd = soundFreqSweep(500, 1000, .01);    else        correctSnd = [];        incorrectSnd = [];    endelse    correctSnd = [];    incorrectSnd = [];end% ensure the starting values are in rangeif any(stairParams.adjustableVarStart>numLevels) || any(stairParams.adjustableVarStart<1)    error('Starting values are out of range (range = 1 to number of stim levels).\n');end% initialize all the bookkeeping stuff%data = ones(1,numStairs)*NaN;data = cell(numStairs,1);stairHistory.numTrials = zeros(1,numStairs);stairHistory.numConsecCorrect = zeros(1,numStairs);stairHistory.numConsecIncorrect = zeros(1,numStairs);stairHistory.runDirection = ones(1,numStairs);stairHistory.curAdjustIndex = stairParams.adjustableVarStart;stairHistory.numReversals = zeros(1,numStairs);stairHistory.done = zeros(1,numStairs);numAlternatives = length(stairParams.alternativeVarValues);numLevelVectors = size(stairParams.adjustableVarValues, 1);% initialize the dataSum stufffor curStair=1:numStairs    dataSum(curStair).history = [];    dataSum(curStair).condName = stairParams.conditionName(min(size(stairParams.conditionName,1),curStair),:);    dataSum(curStair).stimLevels = stairParams.adjustableVarValues(min(curStair,numLevelVectors),:);    dataSum(curStair).numTrials = zeros(1,numLevels);    dataSum(curStair).numCorrect = zeros(1,numLevels);    dataSum(curStair).reversalStimLevel = ones(1,stairParams.maxNumReversals)*NaN;end% build the appropriate trialGenFuncName (the same data will be used for all staircases)trialGenFuncName = strcat(trialGenFuncName, '(display, stimParams, data{curStair})');% parse the option flagsfor i=1:length(varargin)    switch varargin{i}        case 'precomputeFirstTrial',            % build the trial            fprintf('Building the first trial for each staircase.\n');            for curStair = 1:numStairs                adjustValue = stairParams.adjustableVarValues(min(curStair,numLevelVectors), 1);                stimParams = setfield(stimParams, stairParams.adjustableVarName, adjustValue);                % set the curStair variable values in the appropriate stimParams fields                for i=1:size(stairParams.curStairVars, 1)                    curStairVal(i) = stairParams.curStairVars{i,2}(min(curStair,length(stairParams.curStairVars{i,2})));                    stimParams = setfield(stimParams, stairParams.curStairVars{i,1}, curStairVal(i));                end                [trial, data{curStair}] = eval(trialGenFuncName);            end        case 'precomputeAllTrials',            for curStair = 1:numStairs                fprintf('Building trials for staircase %d\n', curStair);                for adjustIndex = 1:numLevels                    adjustValue = stairParams.adjustableVarValues(min(curStair,numLevelVectors), adjustIndex);                    % set the adjustable variable value                    stimParams = setfield(stimParams, stairParams.adjustableVarName, adjustValue);                    % set the random variable values in the appropriate stimParams fields                    for i=1:size(stairParams.randomVars, 1)                        randVal(i) = stairParams.randomVars{i,2}(ceil(rand*length(stairParams.randomVars{i,2})));                        stimParams = setfield(stimParams, stairParams.randomVars{i,1}, randVal(i));                    end                    % set the curStair variable values in the appropriate stimParams fields                    for i=1:size(stairParams.curStairVars, 1)                        curStairVal(i) = stairParams.curStairVars{i,2}(min(curStair,length(stairParams.curStairVars{i,2})));                        stimParams = setfield(stimParams, stairParams.curStairVars{i,1}, curStairVal(i));                    end                    % randomly choose and then set the alternative variable                    altIndex = round(rand*(numAlternatives-1))+1;                    altValue = stairParams.alternativeVarValues(altIndex);                    stimParams = setfield(stimParams, stairParams.alternativeVarName, altValue);                    % build the trial                    [trial{curStair, adjustIndex}, data{curStair}] = eval(trialGenFuncName);                end            end        otherwise,            fprintf('\nWARNING: doStaircase unrecognized option flag "%s".\n', varargin(i));    endendfprintf('Ready to begin the trials...\n');if ~isfield(display, 'fixColorRgb'),    display.fixColorRgb = [0 display.maxRgbValue 0 display.maxRgbValue];end% prepare the logfor i=1:length(logFID)    fprintf(logFID(i), '\ncurStair\ttrial\tadjustValue(%s)\tcorrect\taltValue(%s)\t', ...        stairParams.adjustableVarName, stairParams.alternativeVarName);    for j=1:size(stairParams.randomVars, 1)        fprintf(logFID(i), '%s\t', stairParams.randomVars{j,1});    end    for j=1:size(stairParams.curStairVars, 1)        fprintf(logFID(i), '%s\t', stairParams.curStairVars{j,1});    end    fprintf(logFID(i), '\n');endcurStair = round(rand*(numStairs-1))+1;abort = 0;pressKey2Begin(display,0);% main staircase loopwhile (~all(stairHistory.done) & ~abort)    if exist('trialArray', 'var')        % clear the keyboard queue        %FlushEvents('keyDown');        preTrialSecs = 0;        % run pre-built trial        response = doTrial(display, trialArray{curStair, stairHistory.curAdjustIndex(curStair)}, priority);    else        preTrialSecs = GetSecs;        % we need to build the trial        adjustValue = stairParams.adjustableVarValues(min(curStair,numLevelVectors), ...            stairHistory.curAdjustIndex(curStair));        correctStepIndex = min(length(stairParams.correctStepSize), stairHistory.numReversals(curStair)+1);        incorrectStepIndex =  min(length(stairParams.incorrectStepSize), stairHistory.numReversals(curStair)+1);        % set the adjustable variable value        stimParams = setfield(stimParams, stairParams.adjustableVarName, adjustValue);        % set the random variable values in the appropriate stimParams fields        for i=1:size(stairParams.randomVars, 1)            randVal(i) = stairParams.randomVars{i,2}(ceil(rand*length(stairParams.randomVars{i,2})));            stimParams = setfield(stimParams, stairParams.randomVars{i,1}, randVal(i));        end        % set the curStair variable values in the appropriate stimParams fields        for i=1:size(stairParams.curStairVars, 1)            curStairVal(i) = stairParams.curStairVars{i,2}(min(curStair,length(stairParams.curStairVars{i,2})));            stimParams = setfield(stimParams, stairParams.curStairVars{i,1}, curStairVal(i));        end        % randomly choose and then set the alternative variable        altIndex = round(rand*(numAlternatives-1))+1;        altValue = stairParams.alternativeVarValues(altIndex);        stimParams = setfield(stimParams, stairParams.alternativeVarName, altValue);        % build the trial        [trial, data{curStair}] = eval(trialGenFuncName);        % clear the keyboard queue        %FlushEvents('keyDown');        preTrialSecs = GetSecs-preTrialSecs;        % run the trial        response = doTrial(display, trial, priority, showTimingFlag);    end    postTrialSecs = GetSecs;    respCode = [];    if isfield(stairParams, 'responseSet')        % wait for the response        while (isempty(respCode))            %aChar = GetChar;            [keyDown,keySecs,keyCode] = KbCheck;            if(keyDown)                response.keyCode = keyCode;                response.secs = keySecs;                response = getKeyLabel(response);            end            if(~isempty(strfind(lower(response.keyLabel),'q')))                respCode = -1;                abort = 1;            else                respCode = strfind(stairParams.responseSet, response.keyLabel);            end            WaitSecs(0.01); % Give other processes some CPU time        end    end    correct = (respCode == altIndex);    % update dataSum    if ~abort        stairHistory.numTrials(curStair) = 	stairHistory.numTrials(curStair) + 1;        dataSum(curStair).history(stairHistory.numTrials(curStair)) = adjustValue;        i = find(dataSum(curStair).stimLevels == adjustValue);        if isempty(i)            error('doStaircase: missing stimLevel in dataSum- data may not be valid!');        end        dataSum(curStair).numTrials(i) = dataSum(curStair).numTrials(i) + 1;        if correct            % auditory feedback            if ~isempty(correctSnd) soundAsync(correctSnd); end            dataSum(curStair).numCorrect(i) = dataSum(curStair).numCorrect(i) + 1;        else            if ~isempty(incorrectSnd) soundAsync(incorrectSnd); end        end    end    % print out the log    for i=1:length(logFID)        % incase altValues are characters: num2str(altValue) will work with characters, ints and floats        fprintf(logFID(i), '%d\t%d\t%.4f\t%d\t%s\t', curStair, stairHistory.numTrials(curStair), ...            adjustValue, correct, num2str(altValue));        for j=1:size(stairParams.randomVars, 1)            fprintf(logFID(i), '%.4f\t',  randVal(j));        end        for j=1:size(stairParams.curStairVars, 1)            fprintf(logFID(i), '%.4f\t',  curStairVal(j));        end        fprintf(logFID(i), '\n');    end    % save the dataSum file in case of a crash or error    save('dataSumTemp', 'dataSum');    % adjust the adjustable    if correct        stairHistory.numConsecCorrect(curStair) = stairHistory.numConsecCorrect(curStair) + 1;        stairHistory.numConsecIncorrect(curStair) = 0;        if mod(stairHistory.numConsecCorrect(curStair), stairParams.numCorrectForStep) == 0            stairHistory.curAdjustIndex(curStair) = stairHistory.curAdjustIndex(curStair) ...                + stairParams.correctStepSize(correctStepIndex);            % check to see if this is a reversal            % if the current run is negative (the 'incorrect' direction), then meeting the            % numConsecCorrect criterion constitutes a reversal.            if stairHistory.runDirection(curStair) == -1                stairHistory.numReversals(curStair) = stairHistory.numReversals(curStair) + 1;                dataSum(curStair).reversalStimLevel(stairHistory.numReversals(curStair)) = adjustValue;                stairHistory.runDirection(curStair) = +1;            end        end    else        stairHistory.numConsecIncorrect(curStair) = stairHistory.numConsecIncorrect(curStair) + 1;        stairHistory.numConsecCorrect(curStair) = 0;        if mod(stairHistory.numConsecIncorrect(curStair), stairParams.numIncorrectForStep) == 0            stairHistory.curAdjustIndex(curStair) = stairHistory.curAdjustIndex(curStair) ...                + stairParams.incorrectStepSize(incorrectStepIndex);            % check to see if this is a reversal            % if the current run is positive (the 'correct' direction), then meeting the            % numConsecIncorrect criterion constitutes a reversal.            if stairHistory.runDirection(curStair) == +1                stairHistory.numReversals(curStair) = stairHistory.numReversals(curStair) + 1;                dataSum(curStair).reversalStimLevel(stairHistory.numReversals(curStair)) = adjustValue;                stairHistory.runDirection(curStair) = -1;            end        end    end    % ensure adjustable isn't out of range    % Note that if we have gone out of range, then we should (and do) count this as a    % reversal because it means the observer has hit one of the boundaries.  If we don't    % do something like this, the observer may get stuck at one of the bounds and do many    % unnecessary trials there!    if stairHistory.curAdjustIndex(curStair) > numLevels        % count this as a reversal        stairHistory.numReversals(curStair) = stairHistory.numReversals(curStair) + 1;        dataSum(curStair).reversalStimLevel(stairHistory.numReversals(curStair)) = adjustValue;        % constrain curAdjustIndex to the bounds        stairHistory.curAdjustIndex(curStair) = numLevels;    elseif stairHistory.curAdjustIndex(curStair) < 1        % count this as a reversal        stairHistory.numReversals(curStair) = stairHistory.numReversals(curStair) + 1;        dataSum(curStair).reversalStimLevel(stairHistory.numReversals(curStair)) = adjustValue;        % constrain curAdjustIndex to the bounds        stairHistory.curAdjustIndex(curStair) = 1;    end    % check to see if we are done with this staircase    if stairHistory.numTrials(curStair) >= stairParams.maxNumTrials ...            | stairHistory.numReversals(curStair) >= stairParams.maxNumReversals        stairHistory.done(curStair) = 1;    end    % choose the curStair pseudorandomly, giving preference to staircases that are less done.    completeIndex = stairHistory.numTrials./stairParams.maxNumTrials - randn(size(stairHistory.numTrials))*.2;    curStair = find(completeIndex == min(completeIndex));    curStair = curStair(round(rand*(length(curStair)-1))+1);    % wait for an ITI, if needed    postTrialSecs = GetSecs-postTrialSecs;    % we use the previous pre-trial time as a guess for how long the next    % pre-trial prep time will take.    if(~all(stairHistory.done) & ~abort & preTrialSecs+postTrialSecs<stairParams.iti)        waitTill(stairParams.iti-preTrialSecs+postTrialSecs);    endend%ListenChar(false);return;
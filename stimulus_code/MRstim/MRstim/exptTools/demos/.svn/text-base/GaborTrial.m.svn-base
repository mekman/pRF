function [trial, data] = GaborTrial(display, stimParams, data)% trial = GaborTrial(display, stimParams)numStimColors = display.stimRgbRange(2)-display.stimRgbRange(1)+1;% We want to guarantee that the stimulus is modulated about the backgroundmidStimColor = display.backColorIndex;% display.gamma contains the gamma values needed to achieve each of% numGammaEntries luminances, in a linear map. Thus, numGammaEntries/2 will% yield the mean luminance, 1 will yield the minimum luminance, and% numGammaEntries will yield the max luminance.numGammaEntries = size(display.gamma,1);midGammaIndex = round(numGammaEntries/2);halfStimRange = stimParams.contrast*(numGammaEntries-1)*0.5;gammaIndices = linspace(-halfStimRange, halfStimRange, numStimColors)+midGammaIndex;cmap = zeros(display.maxRgbValue+1,3,1);cmap(display.stimRgbRange(1)+1:display.stimRgbRange(2)+1,:) = display.gamma(round(gammaIndices),:);% poke in reserved colorscmap(1,:) = [0 0 0];cmap(end,:) = [1 1 1];% poke in the exact background color so that we can be sure it is in the% center of the cmap (it might not be due to rounding).cmap(display.backColorIndex, :) = display.gamma(midGammaIndex, :);% Create the sequencenumFrames = round(display.frameRate * stimParams.duration);seq = [-1 (1:numFrames+1)];% Compute the images (if needed)% only compute images if they don't exist yet (we aren't manipulating anything that% requires recomputing the images, only the colormaps need to be recomputed).if(~exist('data','var') | isempty(data))	% Generate images for both positions	radiusPix = 2*floor(angle2pix(display, stimParams.size/2)/2)+1;	spreadPix =  2*floor(angle2pix(display, stimParams.spread)/2)+1;    	[x,y] = meshgrid(-radiusPix:radiusPix,-radiusPix:radiusPix);    sz = size(x);        if strcmp(stimParams.temporalEnvelopeShape,'gaussian')        t = stimParams.temporalSpread/stimParams.duration;        temporalWindow = exp(-.5*(([.5:numFrames]-numFrames/2)./(t*numFrames)).^2);    else        temporalWindow = ones(1,numFrames);        len = ceil((stimParams.duration-stimParams.temporalSpread)/2*display.frameRate);        endWin = (cos([0:len]/len*pi)+1)/2;        temporalWindow(end-len+1:end) = endWin;        temporalWindow(1:len) = fliplr(endWin);    end        sf = stimParams.cyclesPerDegree*display.pixelSize*2*pi;    phaseInc = stimParams.cyclesPerSecond/display.frameRate*2*pi;    angle = stimParams.orientDegrees*pi/180;    a = cos(angle)*sf;	b = sin(angle)*sf;    img = cell(numFrames+1,1);    phase = stimParams.phaseDegrees*pi/180;    spatialWindow = exp(-((x/spreadPix).^2)-((y/spreadPix).^2));	for ii=1:numFrames		phase = phase+phaseInc;		img{ii} = temporalWindow(ii)*spatialWindow.*sin(a*x+b*y+phase);    end    img{numFrames+1} = zeros(sz);	% compute grating	%img(:,:) = exp(-((x/spreadPix).^2) - ((y/spreadPix).^2)) ...	%			.* sin(x*.5*stimParams.cycles/radiusPix*2*pi);	% scale to the appropriate cmap range    for(ii=1:length(img))        img{ii} = uint8(round(img{ii}.*(numStimColors/2-1)+midStimColor));    end    			    data = createStimulusStruct(img, cmap, seq, []);    data.imSize = sz;	clear('img');	data = makeTextures(display, data);	else	% the stimulus exists in data, so we just need to update the cmaps and seq	data.cmap = cmap;	data.seq = seq;endclear('cmap');clear('seq');sz = data.imSize;c = display.numPixels/2;eccenPix = round(angle2pix(display, stimParams.eccentricity));if stimParams.testPosition == 'L'    % left, top, right, bottom    data.destRect = round([c(1)-sz(1)/2-eccenPix c(2)-sz(2)/2]);else    data.destRect = round([c(1)-sz(1)/2+eccenPix c(2)-sz(2)/2]);enddata.destRect = [data.destRect data.destRect+sz];% build the trialtrial = addTrialEvent(display,[],'stimulusEvent', 'stimulus', data);return;
function stimRGB = cone2RGB(display,stimLMS,backRGB,sensors)%%   stimRGB = cone2RGB(display,stimLMS,[backRGB],[sensors])%%AUTHOR: Wandell, Baseler, Press%DATE:   09.10.98%PURPOSE:%%   Calculate the RGB values (stimRGB.dir, stimRGB.scale) needed%   to create a  stimulus defined by stimLMS.dir, stimLMS.scale%   and the backRGB.dir backRGB.scale values. %   %   This code works for a single stimLMS.dir vector, but%   stimLMS.scale may be a vector.%   %   The returned values in stimRGB.scale are the RGB scale factors%   needed to obtain the specified LMS scale.  The cone contrast%   is calculated with respect to the background, as in%   %     (lmsStimPlusBack - lmsBack) ./ lmsBack%     %   % ARGUMENTS%%  display:  .spectra contains the monitor spectral, is needed%  stimLMS:  .dir    is the color direction of the contrast stimulus%            .scale  is the scale factor%            When the stimLMS.dir is cone isolating, the%            scale factor is the same as contrast.  The%            definition of a single contrast value is problematic for other%            directions. %  backRGB:  (optional) .dir and  .scale define the mean RGB of background,%            so that backRGB.dir*backRGB.scale is a vector of%            linear rgb values.%  sensors:  (optional) A 361x3 matrix of sensor wavelength sensitivities.%            Default:  Stockman sensors.%% RETURNS%            % stimLMS:   .maxScale   the largest permissible scale (re gamut%            and background).% stimRGB:  .dir    color direction of the rgb vector%           .scale  vector of scale values.%            % SEE ALSO:%    findMaxConeScale(); RGB2Cone();%% ISSUES:%    It is a bit odd that we send in backRGB and stimLMS.  We did%   this because when we design the stimuli, we usually pick a%   background level near the middle of RGB, say [.5 .5 .5],%   without worrying much about it.  If we had sent in backLMS,%   it would usually be less convenient.%   % 98.11.04 rfd: made stockman persistent so that it needn't be% 				loaded from disk each time this is called.		% 98.11.17 rfd & wap: modified findMaxConeScale to %				properly scale the requested stimLMS so that%				the resulting stimuli will have the requested LMS.%				(See findMaxConeScale for details.)%% Set up input defaults%if ~exist('backRGB','var')  % disp('Cone2RGB: Using default background of [0.5 0.5 0.5]')  backRGB.dir = [1 1 1]';  backRGB.scale = 0.5;endif ~exist('sensors', 'var')  % disp('Cone2RGB: Using Stockman fundamentals')  % keep sensors in memory so that they aren't loaded each time  persistent stockman;  if isempty(stockman)  	load stockman  end  sensors = stockman;endif ~isfield(display,'spectra')  error('The display structure requires a spectra field');else  displayP = display.spectra;end[stimLMS stimRGB] = findMaxConeScale(display,stimLMS,backRGB,sensors);for ii=1:length(stimLMS.scale)	if (stimLMS.scale(ii) > stimLMS.maxScale)		if (stimLMS.scale(ii)-stimLMS.maxScale < 0.001)			stimLMS.scale(ii) = stimLMS.maxScale;		else	      	str = sprintf('Requested contrast ( %.3f) exceeds maximum (%.3f)\n', ...		  	stimLMS.scale(ii),stimLMS.maxScale);      		error(str);		end  	end    % When stimRGB.scale equals stimRGB.maxScale,     %     %      stimLMS.scale = stimLMS.maxScale    %     % Everything is linear, so to obtain     %     %    stimLMS.scale = stimLMS.maxScale * (stimRGB.scale/stimRGB.maxScale)    %     % To solve for the stimRGB.scale that yields a stimLMS.scale,    % we invert    %     stimRGB.scale(ii) = (stimLMS.scale(ii)/stimLMS.maxScale)*stimRGB.maxScale;    %   endreturn% Debugging% Compute the stimulus contrast for the various conditions, as% a check.lmsBack = rgb2lms*(backRGB.dir*backRGB.scale);for ii=1:length(stimRGB.scale)  lmsStimPlusBack = rgb2lms*(stimRGB.scale(ii)*stimRGB.dir) + lmsBack;  (lmsStimPlusBack - lmsBack) ./ lmsBackend